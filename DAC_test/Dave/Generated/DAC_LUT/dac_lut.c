/**
 * @file dac_lut.c
 * @date 14-02-18
 * This file is generated by DAVE. Any manual modification done to this file will be lost when the code is regenerated.
 * @cond
 ***********************************************************************************************************************
 * DAC_LUT v4.1.16 - Supports advance waveform generation using look up table(LUT).
 *
 * Copyright (c) 2015, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 *   following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-02-20:
 *     - Initial version
 *
 * 2015-06-20:
 *     - DMA support added.
 *
 * 2015-09-03:
 *     - CPU_CTRL_XMC4 APP initialization is removed.
 *
 * 2015-12-15:
 *     - ANALOG_IO_Init function call added
 *
 * 2018-02-14:
 *     - DMA interrupt disabled if Repetition is : "Endless"
 * @endcond
 *
 */
/***********************************************************************************************************************
 * HEADER FILES
 **********************************************************************************************************************/
#include "dac_lut.h"

/***********************************************************************************************************************
 * MACROS
 **********************************************************************************************************************/

/***********************************************************************************************************************
 * LOCAL DATA
 **********************************************************************************************************************/

/***********************************************************************************************************************
 * LOCAL ROUTINES
 **********************************************************************************************************************/

static void DAC_LUT_ISR_Init(DAC_LUT_ISR_Handle_t*const HandlePtr);
#if (DAC_LUT_SYNC_SECOND_DAC == 1U)
static void DAC_LUT_UpdateNextPointCoupleMode( DAC_LUT_t * HandlePtr );
static void DAC_LUT_UpdateNextPointContinuous( DAC_LUT_t * HandlePtr );
#endif
#if (DAC_LUT_DMA_ENABLED == 1U)
static DAC_LUT_STATUS_t DAC_LUT_DMAConfig(DAC_LUT_t * HandlePtr);
#endif

/**********************************************************************************************************************
* API IMPLEMENTATION
**********************************************************************************************************************/
/*
 * This function configure the the NVIC Node.
 */
static void DAC_LUT_ISR_Init(DAC_LUT_ISR_Handle_t*const HandlePtr)
{
   /*set the priority and sub priority*/
   NVIC_SetPriority((IRQn_Type)HandlePtr->node_id,NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
                             (uint32_t)HandlePtr->priority,(uint32_t)HandlePtr->sub_priority));
   /*Enable the IRQ*/
   NVIC_EnableIRQ((IRQn_Type)HandlePtr->node_id);
}

#if (DAC_LUT_SYNC_SECOND_DAC == 1U)
/* This function will update next point when synchronize second DAC is selected in continuous
 * waveform generation*/
static void DAC_LUT_UpdateNextPointContinuous( DAC_LUT_t * HandlePtr )
{
  uint32_t data0;
  uint32_t data1;

  /* Continuous waveform generation selected */
  if(HandlePtr->wavegen_current_index >= HandlePtr->wavegen_lut_lenght)
  {
    /* lookup table end point reached, reset index */
    HandlePtr->wavegen_current_index = 0U;
  }

  /* LUT wave point index for second DAC CH */
  if(HandlePtr->wavegen_sync_current_index >= HandlePtr->wavegen_sync_lut_lenght)
  {
    /* lookup table end point reached, reset index */
    HandlePtr->wavegen_sync_current_index = 0U;
  }

  data0 = HandlePtr->wave_lut_ptr[HandlePtr->wavegen_current_index++];
  data1 = HandlePtr->wave_lut_coupled_ptr[HandlePtr->wavegen_sync_current_index++];
  if(HandlePtr->data_type == DAC_LUT_DATATYPE_16_BIT)
  {
    data0 = (uint32_t)((data0 & (uint16_t)0xFFF0) >> DAC_LUT_SHIFT_BY_4);
  }
  if(HandlePtr->data_type_sync_ch == DAC_LUT_DATATYPE_16_BIT)
  {
    data1 = (uint32_t)((data1 & (uint16_t)0xFFF0) >> DAC_LUT_SHIFT_BY_4);
  }
  /* Write on DATA01 register */
  XMC_DAC_SimultaneousWrite(HandlePtr->module_ptr,(uint16_t)data0,(uint16_t)data1);

}

/* This function will update next point when synchronize second DAC is selected*/
static void DAC_LUT_UpdateNextPointCoupleMode( DAC_LUT_t * HandlePtr )
{
  uint32_t data0 = 0U;
  uint32_t data1 = 0U;

  /* Number of waveform generation cycles are restricted */
  if(HandlePtr->wavegen_current_cycle >= 0)
  {
    if(HandlePtr->wavegen_current_index >= HandlePtr->wavegen_lut_lenght)
    {
      /* lookup table end point reached, reset index */
      HandlePtr->wavegen_current_index = 0U;
      if(HandlePtr->wavegen_repetition_cycle != 0U)
      {
        HandlePtr->wavegen_current_cycle--;
      }
    }
    data0 = (uint32_t)HandlePtr->wave_lut_ptr[HandlePtr->wavegen_current_index++];
  }

  if(HandlePtr->wavegen_sync_current_cycle >= 0)
  {
    /* LUT wave point index for second DAC CH */
    if(HandlePtr->wavegen_sync_current_index >= HandlePtr->wavegen_sync_lut_lenght)
    {
      /* lookup table end point reached, reset index */
      HandlePtr->wavegen_sync_current_index = 0U;
      if(HandlePtr->wavegen_sync_repetition_cycle != 0U)
      {
        HandlePtr->wavegen_sync_current_cycle--;
      }
    }
    data1 = HandlePtr->wave_lut_coupled_ptr[HandlePtr->wavegen_sync_current_index++];
  }

  if(HandlePtr->data_type == DAC_LUT_DATATYPE_16_BIT)
  {
    data0 = (uint32_t)((data0 & (uint16_t)0xFFF0) >> DAC_LUT_SHIFT_BY_4);
  }
  if(HandlePtr->data_type_sync_ch == DAC_LUT_DATATYPE_16_BIT)
  {
    data1 = (uint32_t)((data1 & (uint16_t)0xFFF0) >> DAC_LUT_SHIFT_BY_4);
  }

  if((HandlePtr->wavegen_current_cycle >= 0)|| (HandlePtr->wavegen_sync_current_cycle >= 0))
  {
    /* Write on DATA01 register */
    XMC_DAC_SimultaneousWrite(HandlePtr->module_ptr,(uint16_t)data0,(uint16_t)data1);
  }
}
#endif

#if (DAC_LUT_DMA_ENABLED == 1U)

/* DMA configuration function */
static DAC_LUT_STATUS_t DAC_LUT_DMAConfig(DAC_LUT_t * HandlePtr)
{
  DAC_LUT_STATUS_t return_status = DAC_LUT_STATUS_SUCCESS;
  GLOBAL_DMA_t * global_dma = HandlePtr->dma_config_ptr->global_dma;
  uint8_t dma_channel = HandlePtr->dma_config_ptr->dma_channel;
  uint8_t status;

  /* Initialize global DMA module */
  status = (uint8_t)GLOBAL_DMA_Init(global_dma);
  status |= (uint8_t)XMC_DMA_CH_Init(global_dma->dma, dma_channel, HandlePtr->dma_config_ptr->dma_ch_config);
  /* CHeck if initialization is successful */
  if(status == 0U)
  {
    if(HandlePtr->wavegen_current_cycle!=0)
    {
        XMC_DMA_CH_EnableEvent(global_dma->dma, dma_channel,
                         ((uint8_t)XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE | (uint8_t)XMC_DMA_CH_EVENT_ERROR));
        XMC_DMA_CH_SetEventHandler(global_dma->dma, dma_channel, DAC_LUT_DMABlockTransferEvntHandler);
    }

	  /* Enable DMA event for block transfer complete and any error during transfer */
    XMC_DMA_CH_SetSourceAddress(global_dma->dma, dma_channel, (uint32_t)HandlePtr->wave_lut_ptr);
    XMC_DMA_CH_SetDestinationAddress(global_dma->dma, dma_channel, (uint32_t)HandlePtr->dac_data_reg_ptr);
    XMC_DMA_CH_Enable(global_dma->dma, dma_channel);

    if(HandlePtr->wavegen_repetition_cycle == 1U)
    {
      /* Stop the DMA transfer after one cycle */
      XMC_DMA_CH_RequestLastMultiblockTransfer(global_dma->dma,dma_channel);
    }
  }
  else
  {
    /* DMA initialization failed */
    return_status = DAC_LUT_STATUS_DMA_INIT_FAIL;
  }

  return(return_status);
}


#endif

/* App API to retrieve the App version information */
DAVE_APP_VERSION_t DAC_LUT_GetAppVersion(void)
{
  DAVE_APP_VERSION_t version;

  version.major = DAC_LUT_MAJOR_VERSION;
  version.minor = DAC_LUT_MINOR_VERSION;
  version.patch = DAC_LUT_PATCH_VERSION;

  return version;
}

/* This API will start the waveform generation*/
void DAC_LUT_Start(DAC_LUT_t * HandlePtr)
{
#if (DAC_LUT_DMA_ENABLED == 1U)
  XMC_DMA_CH_Enable(HandlePtr->dma_config_ptr->global_dma->dma, HandlePtr->dma_config_ptr->dma_channel);
#endif
  XMC_DAC_CH_SetMode(HandlePtr->module_ptr, HandlePtr->ch, XMC_DAC_CH_MODE_DATA);
  /* Check if second DAC is in use */
#if (DAC_LUT_SYNC_SECOND_DAC == 1U)
  XMC_DAC_CH_SetMode(HandlePtr->module_ptr, HandlePtr->sync_ch, XMC_DAC_CH_MODE_DATA);
#endif

  /* If auto interrupt is enabled then update the next point */
  if(DAC_LUT_REFILL_AUTO_INTERRUPT == HandlePtr->refill_sel)
  {
    DAC_LUT_UpdateNextPoint(HandlePtr);
  }
}

/* This API will stop the waveform generation*/
void DAC_LUT_Stop(DAC_LUT_t * HandlePtr)
{
#if (DAC_LUT_DMA_ENABLED == 1U)
  XMC_DMA_CH_Disable(HandlePtr->dma_config_ptr->global_dma->dma, HandlePtr->dma_config_ptr->dma_channel);
#endif
  XMC_DAC_CH_SetMode(HandlePtr->module_ptr, HandlePtr->ch, XMC_DAC_CH_MODE_IDLE);
  /* Check if second DAC is in use */
#if (DAC_LUT_SYNC_SECOND_DAC == 1U)
  XMC_DAC_CH_SetMode(HandlePtr->module_ptr, HandlePtr->sync_ch, XMC_DAC_CH_MODE_IDLE);
#endif
}

/**
 * This function initializes DAC peripheral as per the user configurations
 */

DAC_LUT_STATUS_t DAC_LUT_Init(DAC_LUT_t * HandlePtr)
{
  DAC_LUT_STATUS_t dac_lut_status = DAC_LUT_STATUS_SUCCESS;
  uint8_t api_status = (uint8_t) 0;

  /*Assert variables.*/
  XMC_ASSERT(" DAC_LUT_Init: Passing argument DAC_LUT HandlePtr of type DAC_LUT_t "
      "is Null",(HandlePtr != (DAC_LUT_t *)NULL));

  if(DAC_LUT_STATE_UNINITIALIZED == HandlePtr->state)
  {
    /* Configure interrupt if selected */
    if(DAC_LUT_REFILL_AUTO_INTERRUPT == HandlePtr->refill_sel)
    {
      DAC_LUT_ISR_Init(HandlePtr->isr_config_ptr);
    }
    /* If Auto DMA refill mode is selected then configure DMA */
#if (DAC_LUT_DMA_ENABLED == 1U)
    api_status |= (uint8_t)DAC_LUT_DMAConfig(HandlePtr);
#endif

#if (DAC_LUT_ANALOG_IO_USED == 1U)
  /* ANALOG_IO initialization */
    api_status |= (uint8_t) ANALOG_IO_Init(HandlePtr->analog_io_config_ptr);
#endif

#if (DAC_LUT_SYNC_SECOND_DAC == 1U)
    /* Configure both the Channels */
    XMC_DAC_CH_Init(HandlePtr->module_ptr,HandlePtr->ch,HandlePtr->config_ptr);
    XMC_DAC_CH_Init(HandlePtr->module_ptr,HandlePtr->sync_ch,HandlePtr->sync_config_ptr);

    /* Enable coupled mode */
    XMC_DAC_EnableSimultaneousDataMode(HandlePtr->module_ptr);
    /* Initialize both the DAC CH in Data Mode */
    api_status |= (uint8_t)XMC_DAC_CH_StartDataMode(HandlePtr->module_ptr,HandlePtr->ch,
                                      HandlePtr->input_trigger,HandlePtr->frequency);
    api_status |= (uint8_t)XMC_DAC_CH_StartDataMode(HandlePtr->module_ptr,HandlePtr->sync_ch,
                                            HandlePtr->input_trigger,HandlePtr->frequency);

    /* Check if start after initialization is enabled */
    if(HandlePtr->start_after_init == 0U)
    {
      XMC_DAC_CH_SetMode(HandlePtr->module_ptr, HandlePtr->ch, XMC_DAC_CH_MODE_IDLE);
      XMC_DAC_CH_SetMode(HandlePtr->module_ptr, HandlePtr->sync_ch, XMC_DAC_CH_MODE_IDLE);
    }

    if(1U == HandlePtr->service_request)
    {
      /* Enable Service Request */
      XMC_DAC_CH_EnableEvent(HandlePtr->module_ptr,HandlePtr->ch);
    }

    XMC_DAC_SimultaneousWrite(HandlePtr->module_ptr,0U,0U);
#else
    /* Configure corresponding Channel */
    XMC_DAC_CH_Init(HandlePtr->module_ptr,HandlePtr->ch,HandlePtr->config_ptr);
    /* Initialize corresponding DAC CH in Data Mode */
    api_status |= (uint8_t)XMC_DAC_CH_StartDataMode(HandlePtr->module_ptr,HandlePtr->ch,
                                      HandlePtr->input_trigger,HandlePtr->frequency);

    /* Check if start after initialization is enabled */
    if(HandlePtr->start_after_init == 0U)
    {
      XMC_DAC_CH_SetMode(HandlePtr->module_ptr, HandlePtr->ch, XMC_DAC_CH_MODE_IDLE);
    }

    if(1U == HandlePtr->service_request)
    {
      /* Enable Service Request */
      XMC_DAC_CH_EnableEvent(HandlePtr->module_ptr,HandlePtr->ch);
    }

    XMC_DAC_CH_Write(HandlePtr->module_ptr,HandlePtr->ch,0U);
#endif

    if(api_status != (uint8_t)XMC_DAC_CH_STATUS_OK)
    {
      dac_lut_status = DAC_LUT_STATUS_FAILURE;
    }
    else
    {
      HandlePtr->state = DAC_LUT_STATE_INITIALIZED;
    }
  }
  return dac_lut_status;
}

/* This function will update DAC data register with the next point from LUT */
void DAC_LUT_UpdateNextPoint( DAC_LUT_t * HandlePtr )
{
  /* Update data register based upon the mode selected */

#if (DAC_LUT_SYNC_SECOND_DAC == 1U)
  if((HandlePtr->wavegen_repetition_cycle == 0U) && (HandlePtr->wavegen_sync_repetition_cycle == 0U))
  {
    DAC_LUT_UpdateNextPointContinuous(HandlePtr);
  }
  else
  {
    DAC_LUT_UpdateNextPointCoupleMode(HandlePtr);
  }
#else
  if(HandlePtr->wavegen_repetition_cycle == 0U)
  {
    /* Continuous waveform generation selected */
    if(HandlePtr->wavegen_current_index >= HandlePtr->wavegen_lut_lenght)
    {
      /* lookup table end point reached, reset index */
      HandlePtr->wavegen_current_index = 0U;
    }

    if(HandlePtr->data_type == DAC_LUT_DATATYPE_12_BIT)
    {
      /* Write to corresponding DAC data register */
      XMC_DAC_CH_Write(HandlePtr->module_ptr,HandlePtr->ch,
                           (uint16_t)HandlePtr->wave_lut_ptr[HandlePtr->wavegen_current_index++]);
    }
    else
    {
      /* Write to corresponding DAC data register */
      XMC_DAC_CH_Write(HandlePtr->module_ptr,HandlePtr->ch,
              (uint16_t)((HandlePtr->wave_lut_ptr[HandlePtr->wavegen_current_index++] &
                                                     (uint16_t)0xFFF0) >> DAC_LUT_SHIFT_BY_4));
    }
  }
  else
  {
    /* Number of waveform generation cycles are restricted */
    if(HandlePtr->wavegen_current_cycle >= 0)
    {
      if(HandlePtr->wavegen_current_index >= HandlePtr->wavegen_lut_lenght)
      {
        /* Lookup table end point reached, reset index */
        HandlePtr->wavegen_current_index = 0U;
        HandlePtr->wavegen_current_cycle--;
      }

      if(HandlePtr->data_type == DAC_LUT_DATATYPE_12_BIT)
      {
        /* Write to corresponding DAC data register */
        XMC_DAC_CH_Write(HandlePtr->module_ptr,HandlePtr->ch,
                     (uint16_t)HandlePtr->wave_lut_ptr[HandlePtr->wavegen_current_index++]);
      }
      else
      {
        /* Write to corresponding DAC data register */
        XMC_DAC_CH_Write(HandlePtr->module_ptr,HandlePtr->ch,
                        (uint16_t)((HandlePtr->wave_lut_ptr[HandlePtr->wavegen_current_index++] &
                                                  (uint16_t)0xFFF0) >> DAC_LUT_SHIFT_BY_4));
      }
    }
  }
#endif
}

/* This function will set the start index for waveform generation for corresponding CH */
DAC_LUT_STATUS_t DAC_LUT_SetStartIndex(DAC_LUT_t * HandlePtr,uint8_t ch,uint16_t start_index)
{
  DAC_LUT_STATUS_t status = DAC_LUT_STATUS_SUCCESS;

  if(HandlePtr->refill_sel != DAC_LUT_REFILL_AUTO_DMA)
  {
    if(start_index < HandlePtr->wavegen_lut_lenght )
    {
      if(HandlePtr->ch == ch)
      {
        HandlePtr->wavegen_start_index = start_index;
      }
      else
      {
        HandlePtr->wavegen_sync_start_index = start_index;
      }
    }
    else
    {
      /* start index is out of LUT range */
      status = DAC_LUT_STATUS_OUTOF_RANGE;
    }
  }
  else
  {
    /* In DMA refill mode it is not possible to change start index through API */
    status = DAC_LUT_STATUS_FAILURE;
  }

  return status;
}

/*This function will set the current index of LUT waveform generation for corresponding CH in run time */
DAC_LUT_STATUS_t DAC_LUT_SetIndex(DAC_LUT_t * HandlePtr,uint8_t ch,uint16_t lut_index)
{
  DAC_LUT_STATUS_t status = DAC_LUT_STATUS_SUCCESS;

  if(HandlePtr->refill_sel != DAC_LUT_REFILL_AUTO_DMA)
  {
    if(lut_index < HandlePtr->wavegen_lut_lenght )
    {
      if(HandlePtr->ch == ch)
      {
        HandlePtr->wavegen_current_index = lut_index;
      }
      else
      {
        HandlePtr->wavegen_sync_current_index = lut_index;
      }
    }
    else
    {
      /* start index is out of LUT range */
      status = DAC_LUT_STATUS_OUTOF_RANGE;
    }
  }
  else
  {
    /* In DMA refill mode it is not possible to change current index through API */
    status = DAC_LUT_STATUS_FAILURE;
  }
  return status;
}

/* This function will return the current index of LUT waveform generation for corresponding CH */
uint16_t DAC_LUT_GetIndex(DAC_LUT_t * HandlePtr,uint8_t ch)
{
  uint16_t lut_index = 0U;
  /* In DMA refill mode it is not possible to get current index through API */
  if(HandlePtr->refill_sel != DAC_LUT_REFILL_AUTO_DMA)
  {
    if(HandlePtr->ch == ch)
    {
      lut_index = HandlePtr->wavegen_current_index;
    }
    else
    {
      lut_index = HandlePtr->wavegen_sync_current_index;
    }
  }
  return lut_index;
}

/* This function will reset the waveform generation current index to start index */
void DAC_LUT_ResetIndex(DAC_LUT_t * HandlePtr)
{
#if (DAC_LUT_DMA_ENABLED == 1U)
  /* Reset the DMA source address */
  XMC_DMA_CH_SetSourceAddress(HandlePtr->dma_config_ptr->global_dma->dma,
           HandlePtr->dma_config_ptr->dma_channel, (uint32_t)HandlePtr->wave_lut_ptr);
#else
  HandlePtr->wavegen_current_index = HandlePtr->wavegen_start_index;
#if (DAC_LUT_SYNC_SECOND_DAC == 1U)
  /* Second DAC synchronize option is selected */
  HandlePtr->wavegen_sync_current_index = HandlePtr->wavegen_sync_start_index;
#endif
#endif
}

/* This function will configure repetition cycles for waveform generation for selected CH */
DAC_LUT_STATUS_t DAC_LUT_SetRepetition(DAC_LUT_t * HandlePtr,uint8_t ch,uint16_t repetition)
{
  DAC_LUT_STATUS_t status = DAC_LUT_STATUS_SUCCESS;

  /* If DMA is enabled then always set the repetition for ch instead of synch channel. */
  if((0U < repetition) && (DAC_LUT_MAX_REPETITION_CYCLES >= repetition))
  {
    if((HandlePtr->ch == ch)||(HandlePtr->refill_sel == DAC_LUT_REFILL_AUTO_DMA))
    {
      if(repetition == 1U)
      {
        HandlePtr->wavegen_repetition_cycle = 1U;
        HandlePtr->wavegen_current_cycle = 0;
      }
      else
      {
        HandlePtr->wavegen_repetition_cycle = repetition - 1U;
        HandlePtr->wavegen_current_cycle = (int16_t)HandlePtr->wavegen_repetition_cycle;
      }
    }
    else
    {
      if(repetition == 1U)
      {
        HandlePtr->wavegen_sync_repetition_cycle = 1U;
        HandlePtr->wavegen_sync_current_cycle = 0;
      }
      else
      {
        HandlePtr->wavegen_sync_repetition_cycle = repetition - 1U;
        HandlePtr->wavegen_sync_current_cycle = (int16_t)HandlePtr->wavegen_sync_repetition_cycle;
      }
    }
  }
  else
  {
    /* repetition cycles are out of range */
    status = DAC_LUT_STATUS_OUTOF_RANGE;
  }
  return status;
}

/* This function will return configured repetition cycles for the waveform generation for selected CH */
uint16_t DAC_LUT_GetRepetition(DAC_LUT_t * HandlePtr,uint8_t ch)
{
  uint16_t repetition;
  /* If DMA is enabled then always return the repetition for ch instead of synch channel. */
  if((HandlePtr->ch == ch) ||(HandlePtr->refill_sel == DAC_LUT_REFILL_AUTO_DMA))
  {
    repetition = HandlePtr->wavegen_repetition_cycle + 1U;
  }
  else
  {
    repetition = HandlePtr->wavegen_sync_repetition_cycle + 1U;
  }
  return repetition;
}

/* This function will change the waveform generation LUT address to user defined LUT address for selected CH */
DAC_LUT_STATUS_t DAC_LUT_ChangeLutAddress(DAC_LUT_t * HandlePtr,uint8_t ch,uint32_t *address)
{
  DAC_LUT_STATUS_t status = DAC_LUT_STATUS_SUCCESS;
#if (DAC_LUT_DMA_ENABLED == 1U)
  uint8_t api_status;
#endif
  if(address != NULL)
  {
    /* If DMA is enabled then always update the LUT address for CH instead of synch channel. */
    if((HandlePtr->ch == ch)||(HandlePtr->refill_sel == DAC_LUT_REFILL_AUTO_DMA))
    {
      HandlePtr->wave_lut_ptr = (uint32_t*)(void*)address;
#if (DAC_LUT_DMA_ENABLED == 1U)
      XMC_DMA_CH_Disable(HandlePtr->dma_config_ptr->global_dma->dma, HandlePtr->dma_config_ptr->dma_channel);
      api_status = (uint8_t)DAC_LUT_DMAConfig(HandlePtr);
      if(api_status != (uint8_t)XMC_DAC_CH_STATUS_OK)
      {
        status = DAC_LUT_STATUS_DMA_INIT_FAIL;
      }
#endif
    }
    else
    {
      HandlePtr->wave_lut_coupled_ptr = (uint32_t*)(void*)address;
    }
  }
  else
  {
    /* Null pointer passed as argument */
    status = DAC_LUT_STATUS_NULL_PTR;
  }
  return status;
}

/* This function will generate software trigger to corresponding DAC CH.*/
void DAC_LUT_SoftwareTrigger(DAC_LUT_t * HandlePtr)
{
  XMC_DAC_CH_SoftwareTrigger(HandlePtr->module_ptr, HandlePtr->ch);
#if (DAC_LUT_SYNC_SECOND_DAC == 1U)
  XMC_DAC_CH_SoftwareTrigger(HandlePtr->module_ptr, HandlePtr->sync_ch);
#endif
}

/* This function will refill the DAC data register with lookup table data. */
DAC_LUT_STATUS_t DAC_LUT_ManualSWRefill(DAC_LUT_t * HandlePtr)
{
  DAC_LUT_STATUS_t status = DAC_LUT_STATUS_SUCCESS;
  uint8_t fifo_full;
  fifo_full = (uint8_t)XMC_DAC_CH_IsFifoFull(HandlePtr->module_ptr,HandlePtr->ch);
#if (DAC_LUT_SYNC_SECOND_DAC == 1U)
  fifo_full |= (uint8_t)XMC_DAC_CH_IsFifoFull(HandlePtr->module_ptr,HandlePtr->sync_ch);
#endif

  /* Check FIFO full status */
  if(0U != fifo_full)
  {
    /* FIFO is full. Not possible to update next wave point */
    status =  DAC_LUT_STATUS_FIFO_FULL;
  }
  else
  {
    /* Update next wave point */
    DAC_LUT_UpdateNextPoint(HandlePtr);
  }

  return status;
}
